Experiment Tutorial for the Paper
=================================
This experiment tutorial help you to finish the evaluation described by this `paper <http://pan.baidu.com/s/1kTwt9mJ/>`_. 

It's similar with the evaluation section `Chucky: Exposing Missing Checks in Source Code for Vulnerability Discovery <http://user.informatik.uni-goettingen.de/~fyamagu/pdfs/2014-oakland.pdf/>`_, but the ROC curves are generated by the middle result(The rank lists of similar functions).

To do the experiment, you should do the following steps:

1.  Generate the code database.
2.  Modify the code. 
3.  Run the automatic script.

Generate the Database
---------------------
The database can be generated by joern(2.0-3.0) according to the method Fabian described in Chucky paper.
That is, patch the vulnerability as the original version, then remove one check in one function from the original versions in a round robin fashion to generate such many code versions and then use joern to generate the code graph database for each vulnerable version.
The version and the respective vulnerability number are listed below.

+-----------------+---------------+-----------------------+
| Project         | Vulnerability | #Functions with Check |
+=================+===============+=======================+
|pigin-2.7.3 	  | CVE-2010-3711 | 18	                  |
+-----------------+---------------+-----------------------+
|libpng-1.2.44	  | CVE-2011-2692 | 19          	  |
+-----------------+---------------+-----------------------+
|libtiff-3.9.4	  | CVE-2010-2067 | 9                     |
+-----------------+---------------+-----------------------+
|firefox-4.0	  | CVE-2010-3183 | 10                    |
+-----------------+---------------+-----------------------+
|linux-2.6.34.13  | CVE-2010-2071 | 8                     |
+-----------------+---------------+-----------------------+

Modify the Code
---------------
1. remove the # symbol at the head of the two lines in the ``try`` block of function analyze()::

        #for n in nearestNeighbors:
        #    print str(n)+"\t"+n.location()

   then comment out all the following code in ``try`` block(that means we just print the neighborhood selection result).
2. Define the environment variable ``$NEO4J_HOME`` to point it to your neo4j program directory or change the variable ``cfgfile`` to the absolute location of the configuration file ``neo4j-server.properties``.

3. change the variable ``line`` in neighbor to the line of variable ``org.neo4j.server.database.location`` in the configuration file ``conf/neo4j-server.properties`` of your Neo4j database.::

        line=11

4. Change the value of the ``dbpath`` to the location of all of your database.Note that the directory must be organized as ``$dbpath/$projname/$funcname/.joernIndex``. The projenames and funcnames must be equal to the names listed in the script file ``neighbor``. 

Run the Automatic Script
-------------------------
::

    $ cd chucky-ng/chucky
    $ neighbor
    $ python ROC.py

The shell script ``neighbor`` dump the result of KNN algorithm to the current file directory,
then the ``ROC.py`` read the directory and generate the points in the directory named ``ROC``.

Output Hierarchy
----------------

* The directory ``neighbors`` output by script neighbor will hold the hierarchy ``$neighbors/$projname/$function_name``, for example, ``neighbors/libpng/png_handle_cHRM``.

* The final ROC points will be generated in file ``ROC/$projname-neighbors_ROC``, for example, ``ROC/libpng-neighbors_ROC``).

At last, you can import these files of ROC point lists into drawing program to plot the diagram.
